# 15. Floating Point Arithmetic: Issues and Limitations
> 부동 소수점 연산: 이슈와 제한들


## 15.0 Intro

* 부동 소수점 수들은 컴퓨터 하드웨어 안에서 2진 분수로 표현됨
  * 10진수 분수 예:
  ```python
  >>> 1/10 + 2/100 + 5/1000
  0.125
  ```
  * 마찬가지로 2진수 분수: (= 0.001)
  ```python
  >>> 0/2 + 0/4 + 1/8
  0.125
  ```
 * 안타깝게도 대부분의 10진수 분수는 정확한 2진수 분수로 표현할 수 없음
 * 따라서 실제 컴퓨터 하드웨어에는 10진수 분수를 근사하는 2진수 분수가 저장됨
 * 이 문제는 10진수에서 이해해볼 때 아주 쉬움
   * 1/3 을 10진수 분수에서 근사한다고 가정하면,
   * 아래로 갈 수록 더 잘 근사한 값이 되나, 얼마나 많은 3을 더 쓰던지 정확한 1/3을 표현할 수 없음
   ```python
   0.3
   0.33
   0.333
   ```
 * 이와 마찬가지로 10진수 분수를 2진수 분수로 표현하면 정확할 수 없음
   * 예: 10진수 분수 1/10
   ```python
   0.0001100110011001100110011001100110011001100110011...
   ```
* 그래서 오늘날에는 부동 소수점을 첫 53비트의 앞부분과 2의 제곱 형태의 분모로 2진수 분수가 근사함
  * 예: 10진수 분수 1/10
  ```python
  3602879701896397 / 2 ** 55
  ```
* 많은 사용자들은 출력되는 값의 형태 때문에 이 근사값에 대해 인식하지 않지만 python은 오직 하드웨어에 저장된 10진수를 근사하는 2진수 근사값을 출력할 뿐임
* 대부분의 하드웨어에서 python으로 하여금 실제 2진수 근사값의 10진수를 출력하도록 하면 0.1은 아래와 같음
```python
0.1000000000000000055511151231257827021181583404541015625
```
* 하지만 이는 사람들이 유용하다고 생각하는 것 보다 더 많은 숫자들을 가지므로 
* python은 관리할수 있을만한 정도록 반올림한 값을 보여줌
* 역사적으로 python 프롬프트와 built-in 함수인 repr()은 17개의 숫자들로 표현함, 0.10000000000000001
* 하지만 python 3.1 부터는 가장 짧은 것을 선택할 수 있게 됨, 0.1
* 보다 만족스러운 출력을 위해, format이나 repr 함수를 사용할 수 있음
```python
>>> format(math.pi, '.12g')  # give 12 significant digits
'3.14159265359'

>>> format(math.pi, '.2f')   # give 2 digits after the point
'3.14'

>>> repr(math.pi)
'3.141592653589793'
```
* 우리는 위의 표현들이 하나의 환상임을 인지해야함
```python
>>> .1 + .1 + .1 == .3
False
>>> # round 함수를 이용한 pre-rounding도 소용없음
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
>>> # post-rounding을 하면 우리가 원하는 결과를 얻을 수 있음
>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
```
* "0.1"과 관련한 문제들에 대해 상세한 내용은 아래에서 설명할 예정
* 자주 발생하는 위와 같은 문제들에 대해 더 알고 싶다면, [The Perils of Floating Point](http://www.lahey.com/float.htm)을 참고
* 참고문의 마지막에서 이야기하듯이 쉬운 답은 없음
* 그렇다고 부동 소수점을 지나치게 조심할 필요는 없음
  * 왜냐면 이 현상은 하드웨어의 부동 소수점 표현에 의한 것이고
  * 대부분의 기계에서 한 작업 당 2**53에서 많아봐야 한 부분에서 일어나는 일임
* 그래도 항상 부동 소수점이 근사값이 라는 것은 keep-in-mind 해야함
* 물론 이상하게 동작되는 것으로 보이는 경우가 존재하기는 하지만 
* 대부분의 일반적인 상황에서는 부동 소수점 연산이 우리가 원하는 결과를 보여줄 것임
* 보통의 경우 str()은 십진수 소수를 표현하기에 충분하지만 보다 좋은 제어를 위해서는 str.format()으로 포맷을 정해줄 수 있음
  * 참고: [Format String Syntax](https://docs.python.org/3/library/string.html#formatstrings)
* 만약 정확한 10진수 소수 표현을 원하는 경우에는 decimal 모듈을 사용
  * 이 모듈은 회계 분야나 높은 정밀도를 요구하는 상황에 사용하기에 적합한 10진수 연산들을 가짐
* 다른 형태의 정확한 연산을 지원하는 모듈은 fractions 모듈로 유리수 기반의 연산을 가짐
  * 따라서 1/3과 같은 수를 정확하게 표현함
* 만약 당신이 부동 소수점 연산을 많이 사용하는 사용자라면 
* 파이썬의 수치 연산 패키지와 다른 여러 수학과 통계 연산 패키지들을 제공하는 [SciPy](https://scipy.org) 프로젝트를 권장
* 파이썬은 여러분이 실제 소수 값을 알고 싶어하는 드문 경우의 문제르 돕기 위해 도구들을 제공함
  * float.as_integer_ratio()
* 이 함수를 쓰면 실제 저장된 값을 분수로 표현해줌
```python
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
>>> x == 3537115888337719 / 1125899906842624
True
```
* float.hex()는 한 소수를 16진수로 표현해 실제 저장된 값을 표현
```python
>>> x.hex()
'0x1.921f9f01b866ep+1'
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
```
* 위 표현들은 정확하므로 이 값은 다른 버전의 파이썬(platfom 독립적)이지만
* 이런 포맷을 지원하는 다른 언어에서도 사용할 수 있음(Java나 C99)
* 다른 유용한 도구로는 덧셈 동안의 정밀도 손실을 완화시키는 math.fsum() 함수가 있음
* 이 함수는 총 계를 구할 때 '잃어버진 숫자들'을 track 해서 소수점 에러가 늘어나서 최종 합에 영향을 주는 것을 방지
```python
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
```
* 여기서 퀴즈, []이 있고 없고의 차이는?
```python
>>> 0.1 * 10 == 1.0
True
>>> [0.1] * 10 == 1.0
False
```


## 15.1 Representation Error
> 표현 에러

* 이 장에서는 "0.1" 예제를 자세히 살펴보고
* 어떻게 우리가 원하는 대로 수행할 수 있는지를 볼 거임
* Representation error는 10진수 분수가 2진수로 분수로 정확히 표현될 수 없다는 사실로 부터 나온 개념
* 1/10은 2진수 분수로 정확히 표현할 수 없음
* 현재 대부분의 기계들은 (2000년도 11월 기준) IEEE-754 부동 소수점 연산을 사용하고 
* 대부분의 플랫폼들은 Python의 float를 IEEE-754의 "double precision"에 매핑시킴
* 754 double은 53bit의 정확도를 가짐
* 따라서 컴퓨터는 0.1을 이 정확도에 맞춰 최대한 가까운 수로 나타내려고 노력함
* 이 수는 J/2**N 으로 표현됨 (J는 53bit의 정수타입)
* 다시 쓰면,
```python
1 / 10 ~= J / (2**N)
J ~= 2**N / 10
```
* 그리고 J가 정확히 53bit(>= 2**52 그리고 < 2**53)임을 기억하면 N의 최고의 값은 56이 됨
* (10이 2**3 보다 크므로)
```python
>>> 2**52 <=  2**56 // 10  < 2**53
True
```
* 56은 J를 53bit로 남기는 하나 뿐인 값이다. 
* 그렇게 되면 J의 값은 반올림한 몫이 됨
* divmod(): 몫과 나머지를 반환하는 내장 함수
```python
>>> q, r = divmod(2**56, 10)
>>> r
6
```
* 나머지 값이 5가 넘으므로 반올림하면,
```python
>>> q+1
7205759403792794
```
* 따라서 754 double precision으로 가장 정확한 값은,
```python
7205759403792794 / 2 ** 56
```
* 분자와 분모를 모두 2로 약분하면,
```python
3602879701896397 / 2 ** 55
```
* 우리가 반올림을 했기 때문에 이 값은 사실 1/10보다 살짝 큼
* 반올림을 안하면 1/10보다 살짝 작겠지만 우리는 절대 정확한 1/10을 가질 수 없음
* 컴퓨터는 1/10 대신 위의 분수만을 볼 수 있음
```python
>>> 0.1 * 2 ** 55
3602879701896397.0
```
* * 따라서 이 분수 값에 10**55를 곱하면 10진법으로 55번째 자리까지 본다면 아래와 같음
```python
>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
```
* 하지만 Python을 포함한 많은 언어들은 이 55자리 수까지 표현하는 대신 17번째 자리까지 표현함
```python
>>> format(0.1, '.17f')
'0.10000000000000001'
```
* fraction과 decimal 모듈은 위에 사용한 이 계산들을 쉽게 해줌
```python
>>> from decimal import Decimal
>>> from fractions import Fraction

>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)

>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)

>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')

>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'
